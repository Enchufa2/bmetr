[{"path":"/articles/metr-model.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The model","title":"Beethoven's metronome from photographs","text":"Contemporary mechanical metronomes preserve essentially design Maelzel’s metronome. angular frequency oscillation, \\(\\Omega\\), obtained function three multiplicative terms: \\[ \\Omega = f_\\mathrm{ang}^{-1}(\\theta)\\cdot f_\\mathrm{fric}^{-1}(\\epsilon)\\cdot \\sqrt[]{g\\frac{M'R -\\frac{\\mu'}{2} (l-L) -r}{M'R^2 + \\frac{\\mu'}{3} ( L^2 + l^2- lL) + r^2}} \\] last term draws classical expression ideal double pendulum, includes corrections account effect moment inertia non-negligible mass, \\(\\mu\\), rod. parameters gravitational acceleration (\\(g\\)), nondimensionalized lower (\\(M' = M / m\\)) rod (\\(μ' = μ / m\\)) masses, distances lower upper masses shaft (\\(R\\) \\(r\\), respectively), length two ends rod shaft (\\(L\\) \\(l\\), respectively). first two terms, \\(f_\\mathrm{ang}\\) \\(f_\\mathrm{fric}\\), corrections account, respectively, large oscillations (usually ranging \\(θ = 40°\\) \\(60°\\)) friction impulse forces: \\[ f_\\mathrm{ang} (\\theta)= 1 + \\sum_{n=1}^\\infty\\left[ \\frac{(2n-1)!!}{(2n)!!}\\sin^{2n}\\left( \\frac{\\theta}{2} \\right) \\right]^2\\\\ f_\\mathrm{fric} (\\epsilon)= 1 + \\frac{1}{\\pi}\\sin^{-1}\\left(\\frac{\\epsilon}{1-\\epsilon}\\right) - \\frac{1}{\\pi} \\sin^{-1}\\left(\\frac{\\epsilon}{1+\\epsilon}\\right) \\] \\(\\epsilon = \\frac{\\tau_\\mathrm{roz}}{\\Omega^2 \\theta}\\) nondimensional parameter must range \\(0 \\leq \\epsilon \\leq 0.5\\), equation real solution. proportional friction torque \\(\\tau\\), inversely proportional angular frequency squared moment inertia.","code":""},{"path":"/articles/metr-model.html","id":"measurements","dir":"Articles","previous_headings":"The model","what":"Measurements","title":"Beethoven's metronome from photographs","text":"contemporary metronome used validate model. First, angular frequency metronome mark measured means extracting tickling period 15-second audio samples. package contains sample file audio recorded 100 bpm. steps measure frequency: Normalize square signal. Remove noise (just zeroing values 0.5). Find peaks sensitivity 50 ms (see help(find_peaks)). Compute differences (samples) transform. sample file: Peak detection sample file. procedure repeated files: measurements included metr.neewer data set:","code":"f.raw <- tuneR::readWave(\"100.wav\") f <- tuneR::normalize(f.raw)^2 f@left[f@left < 0.5] <- 0 peaks <- find_peaks(f@left, f@samp.rate * 0.05)  tuneR::plot(f.raw) points(peaks/f@samp.rate, abs(f.raw@left[peaks]), col=\"red\", pch=19) period <- diff(peaks) / f@samp.rate set_errors(60) / set_errors(mean(period), sd(period)/sqrt(length(period))) ## 96.4(4) wav <- Sys.glob(paste0(PATH_WAVS, \"/*\")) mark <- as.numeric(sub(\".wav\", \"\", basename(wav)))  bpm <- do.call(c, lapply(wav, function(x) {   f <- tuneR::normalize(tuneR::readWave(x))^2   f@left[f@left < 0.5] <- 0   peaks <- find_peaks(f@left, f@samp.rate * 0.05)   period <- diff(peaks) / f@samp.rate   set_errors(60) / set_errors(mean(period), sd(period)/sqrt(length(period))) })) head(metr.neewer) ##   mark      bpm    bpm.se ## 1   40 37.65203 0.6741290 ## 2   42 39.50508 0.6750543 ## 3   44 41.97662 0.6010792 ## 4   46 44.11887 0.5014112 ## 5   48 45.99899 0.5032427 ## 6   50 47.88837 0.5011762"},{"path":"/articles/metr-model.html","id":"model-accuracy","dir":"Articles","previous_headings":"The model","what":"Model accuracy","title":"Beethoven's metronome from photographs","text":", metronome dismantled model parameters measured (dimensions masses). model achieves even better accuracy calibration set manufacturer (MAE less 2 bpm, compared MAE 3 bpm metronome scale). Model validation. parametrization contemporary metronome compared experimental oscillation frequency. noted experimental results exactly follow 1:1 relation (gray line), means calibration scale small error, model accurately predicts . model Forsén et al. (2013), uses double pendulum without corrections, included completeness.","code":"# measurements for the masses # M <- set_errors(30.8, 0.01) # mu <- set_errors(3.8, 0.01)  # correction for L = R, as for the rest of the metronomes metr.params[1,]$L <- metr.params[1,]$R M <- set_errors(31.01, 0.01) m <- set_errors(7.1, 0.01) mu <- set_errors(3.59, 0.01) M. <- M / m mu. <- mu / m  # gravitational acceleration g <- set_errors(9.807, 0.04)  # attach rcm, l, R, L, A metr.params %>%   filter(model == \"Neewer\") %>%   unite_errors() %>%   attach()  neewer <- metr.marks %>%   filter(model == \"Neewer\") %>%   left_join(metr.neewer, by=\"mark\") %>%   unite_errors()  comparative <- neewer %>%   mutate(Model  = metr_model(r+rcm, R, M., l, L, mu., g, A)) %>%   mutate(Forsen = metr_model(r+rcm, R, M., l, L, 0,   g, 0)) %>%   gather_errors(\"series\", \"value\", \"Model\", \"Forsen\", \"bpm\") %>%   mutate(series = sub(\"Forsen\", \"Forsén et al. (2013)\", series)) %>%   mutate(series = sub(\"bpm\", \"Experimental\", series)) %>%   mutate(series = reorder(factor(series), -drop_errors(value)))  ggplot(comparative) +   aes(mark, drop_errors(value), color=series) +   ggthemes::geom_rangeframe(aes(y=drop_errors(bpm)), data=neewer, color=\"black\") +   geom_abline(slope=1, color=\"gray\") + geom_point(size=.7) +   geom_errorbar(aes(ymin=errors_min(value), ymax=errors_max(value)), size=.3) +   geom_smooth(method=\"gam\", size=.3) +   labs(x=\"Metronome mark [bpm]\", y=\"Oscillation frequency [bpm]\", color=NULL) +   theme(legend.position=c(0, 1), legend.justification=c(0, 1),         axis.title.y=element_text(hjust=0.2), axis.title.x=element_text(hjust=0.5))"},{"path":"/articles/metr-model.html","id":"effect-of-corrections","dir":"Articles","previous_headings":"The model","what":"Effect of corrections","title":"Beethoven's metronome from photographs","text":"contemporary metronome used study effect kind correction. end, true mass rod, true oscillation angle maximum friction allowed model (\\(\\epsilon = 0.5\\)) separately compared null model (null mass, oscillation angle friction) along whole scale range. Effect corrections throughout whole range metronome, expressed percentage null model (frictionless, small-angle approximation massless rod) metronome mark. expected, considering mass rod contributes model accuracy, thanks escapement wheel, effect friction negligible except lowest oscillation frequencies.","code":"corrections <- neewer %>%   mutate(base     = metr_model(r+rcm, R, M., l, L, 0,   g, 0, 0)) %>%   mutate(Rod      = metr_model(r+rcm, R, M., l, L, mu., g, 0, 0)) %>%   mutate(Angle    = metr_model(r+rcm, R, M., l, L, 0,   g, A, 0)) %>%   mutate(Friction = metr_model(r+rcm, R, M., l, L, 0,   g, 0, 0.5)) %>%   mutate(Rod      = (Rod      - base) / base * 100) %>%   mutate(Angle    = (Angle    - base) / base * 100) %>%   mutate(Friction = (Friction - base) / base * 100) %>%   gather_errors(\"series\", \"value\", \"Rod\", \"Angle\", \"Friction\") %>%   mutate(series = factor(series, levels=c(\"Friction\", \"Angle\", \"Rod\")))  ggplot(corrections) +   aes(mark, drop_errors(value), color=series) +   ggthemes::geom_rangeframe(color=\"black\") +   geom_point(size=.7) +   geom_errorbar(aes(ymin=errors_min(value), ymax=errors_max(value)), size=.3) +   geom_smooth(method=\"gam\", size=.3) +   labs(x=\"Metronome mark [bpm]\", y=\"Correction [%]\", color=\"\") +   theme(legend.position=c(0.98, 0.58), legend.justification=c(1, 0))"},{"path":"/articles/metr-model.html","id":"model-transformation-and-fit","dir":"Articles","previous_headings":"","what":"Model transformation and fit","title":"Beethoven's metronome from photographs","text":"Neglecting effect friction (\\(f_\\mathrm{fric} \\approx 1\\)), express \\(\\Omega^2\\) linear combination polynomial terms \\(r\\): \\[ \\Omega^2=a_0 + b_2 \\left(\\frac{g}{f_\\mathrm{ang}^2(\\theta)}  r + \\Omega^2 r^2 \\right) \\] \\[ a_0= \\frac{g}{f_\\mathrm{ang}^2(\\theta)} \\cdot \\frac{M'R-\\frac{\\mu'}{2}(l-L)}{M'R^2+\\frac{\\mu'}{3}(L^2+l^2-lL)} \\\\ b_2= -\\frac{1}{M'R^2+\\frac{\\mu'}{3}(L^2+l^2-lL)} \\]","code":""},{"path":"/articles/metr-model.html","id":"results","dir":"Articles","previous_headings":"Model transformation and fit","what":"Results","title":"Beethoven's metronome from photographs","text":"linear model fitted two old metronomes dates similar Beethoven’s metronome, patent diagram, contemporary metronome control (see first figure). Model fit oscillation frequency squared function position moving weight. Metronome dimensions measured using Fiji basis total heights reported Tony Bingham’s catalogue. total height assumed 31 cm patent according patent description height oldest metronome. oscillation angle taken maximum inclination, bounded box. Parameter R directly measured metronomes (box hides lower mass), estimated taking account box size patent description. Given lower mass hangs approximately end rod, assumed \\(L \\approx R\\). assumptions, estimated nondimensional masses, \\(M'\\) \\(μ'\\), metronome regression coefficients. Parameter estimation metronomes considered. Estimation nondimensionalized masses \\(\\mu'\\) (rod) \\(M'\\) (lower mass). controls (measuring dismantled metronome precision well measuring distances photograph) accurately estimate true masses contemporary metronome, thus validating estimation rest metronomes.","code":"metr <- metr.marks metr[grep(\"Neewer\", metr$model),]$mark <- rep(metr.neewer$bpm, 2) metr <- metr %>%   group_by(model) %>%   slice(-n())  fit <- metr_fit(metr, metr.params) %>%   unite_errors() %>%   mutate(model = factor(sub(\"Neewer\", \"Control\", model)))  pred <- metr_predict(fit) %>%   cbind(metr[-1]) %>%   unite_errors() %>%   mutate(model = factor(sub(\"Neewer\", \"Control\", model)))  r.squared <- sapply(fit$fit, function(x) summary(x)$adj.r.squared) labels <- mapply(function(x, y) {   bquote(.(x)*\",\" ~ R^2==.(y)) }, levels(pred$model), round(r.squared, 4))  ggplot(pred) +   aes(drop_errors(r), y, color=reorder(model, drop_errors(r), min)) +   ggthemes::geom_rangeframe(color=\"black\") +   geom_ribbon(aes(ymin=lwr, ymax=upr), alpha=.2, size=0) +   geom_point(size=.7) +   geom_errorbarh(aes(xmin=errors_min(r), xmax=errors_max(r)), height=2, size=.3) +   geom_line(aes(y=fit), size=.3) +   scale_color_discrete(labels=labels) +   labs(x=\"r [mm]\", y=expression(Omega^2), color=NULL) +   theme(legend.position=c(1, 1), legend.justification=c(1, 1)) note <- data.frame(model=\"Control (true)\", M.=M., mu.=mu.)  ggplot(fit) +   aes(drop_errors(M.), drop_errors(mu.), color=reorder(model, -drop_errors(mu.))) +   ggthemes::geom_rangeframe(color=\"black\") +   geom_point(size=.7) +   geom_point(aes(shape=model), data=note, color=\"black\", size=2) +   geom_errorbarh(aes(xmin=errors_min(M.), xmax=errors_max(M.)), height=.005, size=.3) +   geom_errorbar(aes(ymin=errors_min(mu.), ymax=errors_max(mu.)), width=.012, size=.3) +   scale_shape_manual(name=NULL, values=8) +   labs(x=\"Nondimensionalized lower mass\", y=\"Nondimensionalized rod mass\", color=NULL) +   guides(color=guide_legend(order=1), shape=guide_legend(order=2)) +   theme(legend.position=c(.95, .95), legend.justification=c(1, 1), legend.spacing.y=unit(-2, \"mm\"))"},{"path":"/articles/metr-model.html","id":"beethovens-metronome","dir":"Articles","previous_headings":"Model transformation and fit","what":"Beethoven’s metronome","title":"Beethoven's metronome from photographs","text":"Results show methodology accurately estimates masses control metronome, thus, take averages old metronomes patent parametrization Beethoven’s metronome, rest parameters equal measurements patent. Beethoven’s metronome estimate, average estimates TB 06, TB 07 metronomes patent.","code":"res <- as.data.frame(fit[3:5, 1:3]) res$model <- as.character(res$model) res[4,] <- list(\"Beethoven's metronome (average)\", mean(res$M.), mean(res$mu.)) knitr::kable(res, caption=table1)"},{"path":"/articles/sym-analysis.html","id":"data-set","dir":"Articles","previous_headings":"","what":"Data set","title":"Beethoven's symphonies analysis","text":"work, selected 36 recordings Beethoven’s complete symphonic works performed 36 different conductors, classified Historically Informed (HI), HI influence Romantic, according analysis L. D. Young (1991) performance reviews included recordings. List recordings studied work. recording details conductor’s name, orchestra, recording dates, label, Unique Product Code (UPC) style. 9th Symphony exceptional various reasons. First, metronomized seven years later others using different device, date purchase known. Second, complexity, especially regarding fourth movement, makes tempo extraction unstable unreliable. Finally, authors questioned validity documental sources tempi first published, months composer’s death, due multiple copy mistakes. reasons, decided exclude analysis. rest data set comprises 1188 audio files (one symphonic movement per track), 169 hours music.","code":""},{"path":"/articles/sym-analysis.html","id":"tempo-extraction","dir":"Articles","previous_headings":"","what":"Tempo extraction","title":"Beethoven's symphonies analysis","text":"Audio files sampled using sliding window. duration defined fraction track, average width 30 seconds, 90% overlap. way, symphonic movement divided number samples, regardless interpreter duration track. Every sample analyzed using state---art tempo extraction algorithm G. Percival et al. (2013, 2014) bases pulse detection self-similarity relations within rhythm musical recording, implemented part open-source framework Marsyas. package contains auxiliary scripts used extract tempo original recordings following procedure (see scripts folder). result following data set:","code":"head(sym.window) ##   symphony movement       conductor n     start  duration tempo ## 1        1        1 Abbado, Claudio 0  0.000000 544.41796    96 ## 2        1        1 Abbado, Claudio 1  0.000000  30.24544   139 ## 3        1        1 Abbado, Claudio 2  3.024544  30.24544   172 ## 4        1        1 Abbado, Claudio 3  6.049088  30.24544   113 ## 5        1        1 Abbado, Claudio 4  9.073633  30.24544   153 ## 6        1        1 Abbado, Claudio 5 12.098177  30.24544   122"},{"path":"/articles/sym-analysis.html","id":"first-steps","dir":"Articles","previous_headings":"Tempo extraction","what":"First steps","title":"Beethoven's symphonies analysis","text":"Sections containing change tempo meter identified located score resulting samples. Different sections movements classified according meter (simple, duple triple meter, binary ternary subdivision). classification important order identify probable tempo harmonics detected tempo extraction algorithm sample. common tempo harmonics kind meter. tempo extraction algorithm relies periodic patterns rhythmic self-similarities. explains many estimated tempi actually multiples submultiples real tempo sample. work, called kinds mistaken tempi “harmonics” due similarity homonym physical phenomenon. common values depend metric structure music displayed . rarely, also detected: () harmonics 2 y 3/4 compound meters; (ii) harmonics 2 y 3/4 meters binary subdivision due occasional use triplets; (iii) harmonic 2/3, triple meters binary subdivision. First, annotate different section numbers based scores. filter erroneous data sections short give meaningful results. histograms tempi, calculate prominent tempo (peak histogram) per symphony, movement section (p.s), average duration (avgdur) prominent tempo per symphony, movement, section conductor (p.sc). Corrections p.s: calculate p.sce enhanced version p.sc various methods:","code":"dt.window <- sym.window %>%   # filter out estimation for the complete movement   filter(n != 0) %>%   # annotate sections   mutate(section = case_when(     (symphony==1 & movement==1 & n<22) |       (symphony==1 & movement==4 & n<6) |       (symphony==2 & movement==1 & n<51) |       (symphony==3 & movement==4 & n>130 & n<206) |       (symphony==4 & movement==1 & n<55) |        (symphony==4 & movement==3 & ((n>37 & n<57) | (n>85 & n<105))) |        (symphony==5 & movement==2 & n>158 & n<179) |        (symphony==5 & movement==4 & n>90 & n<110) |        (symphony==6 & movement==3 & ((n>29 & n<46) | (n>77 & n<94))) |        (symphony==7 & movement==1 & n<80) |        (symphony==7 & movement==3 & ((n>43 & n<78) | (n>112 & n<145) | n>174)) |       (symphony==9 & movement==2 & ((n>110 & n<165) | (n>236))) |        (symphony==9 & movement==3 & ((n>43 & n<70) | (n>113 & n<130)))     ~ 2,     (symphony==5 & movement==4 & n>170) |        (symphony==3 & movement==4 & n>205)     ~ 3,     TRUE ~ 1   )) dt.window <- dt.window %>%   filter(     # invalid tempo data     tempo != 0,     # 4th mvt. for symphonies 3 and 5, too fast and short     !(section==3),     # slow starts     !(symphony==1 & section==2),     !(symphony==2 & movement==1 & section==2 & n<15),     # 9th symphony, due to reasons above     !(symphony==9),     # very short section, irrelevant     !(symphony==5 & movement==2 & section==2),     # issues in the audio file     !(symphony==6 & movement==4 & conductor==\"Cluytens, André\" & n<11)   ) dt.window <- dt.window %>%   # p.s = peak per section   group_by(symphony, movement, section) %>%   mutate(p.s = tmp_prevalent(tempo)) %>%   # exceptions checked by manual inspection   mutate(p.s = ifelse(symphony==1 & movement==3, tmp_prevalent(tempo[1:25]), p.s)) %>%   mutate(p.s = ifelse(symphony==3 & movement==3, 2*tmp_prevalent(tempo[1:47]), p.s)) %>%   mutate(p.s = ifelse(symphony==3 & movement==2, tmp_prevalent(tempo[140:175]), p.s)) %>%   mutate(avgdur = mean(duration)) %>%      # p.sc = peak per section and conductor   group_by(symphony, movement, section, conductor) %>%   mutate(p.sc = tmp_prevalent(tempo)) %>%   # exceptions checked by manual inspection   mutate(p.sc = ifelse(symphony==1 & movement==3, tmp_prevalent(tempo[1:25]), p.sc)) %>%   mutate(p.sc = ifelse(symphony==3 & movement==3, tmp_prevalent(tempo[1:47]), p.sc)) %>%    mutate(p.sc = ifelse(symphony==3 & movement==2, tmp_prevalent(tempo[140:175]), p.sc)) %>%      ungroup() dt.window <- dt.window %>%   mutate(p.s = case_when(     (symphony==1 & movement==1 & section==2) |       (symphony==1 & movement==4 & section==2) |       (symphony==3 & (movement==2 | movement==4) & section==1) |        (symphony==4 & movement==4) |        (symphony==6 & movement==1) |       (symphony==7 & movement==1 & section==2) |       (symphony==7 & movement==2) |        (symphony==8 & movement==4)     ~ p.s / 2,     (symphony==2 & movement==4) |        (symphony==6 & movement==3 & section==2) |       (symphony==7 & movement==3 & section==1)     ~ p.s * 2,     (symphony==6 & movement==2) |        (symphony==3 & movement==1) |       (symphony==6 & movement==5)     ~ p.s / 3,     symphony==6 & movement==3 & section==1     ~ p.s / (3/2),     TRUE ~ p.s   )) dt.window <- dt.window %>%   # add annotations and define p.sce   left_join(sym.marks, by=c(\"symphony\", \"movement\", \"section\")) %>%   mutate(p.sce = p.sc) %>%      # flag whether there's any repetition in each movement   group_by(symphony, movement) %>%   mutate(mov.rep = sum(bar.rep) > 0) %>%   ungroup() %>%      # p.sd = p.s corrected with respect to the avgdur   # it depends on whether there are repetitions in that movement   mutate(p.sd = if_else(     !mov.rep,     p.s*avgdur/duration,     p.s*(1 + 0.5*(avgdur/duration-1)*(cos(pi*(avgdur/duration-1)))^2)   )) %>%      # p.sce must be close to p.sd   group_by(symphony, movement, conductor, section) %>%   mutate(p.sce = tmp_rectify_tsig(p.sce, p.sd, tsig, 0.18, 0.187)) %>%      # additional corrections to p.sce   mutate(p.sce = case_when(     tsig==3 & p.s>90 |        (symphony==2 & movement==1 & section==2 & conductor==\"Hogwood, Christopher\")       ~ tmp_rectify(p.sce, p.sd, 3/4, 0.13, 0.114),     tsig==3 & p.s<90 ~ tmp_rectify(p.sce, p.sd, 2, 0.12, 0.185),     TRUE ~ p.sce   )) %>%   mutate(p.sce = if_else(mov.rep, tmp_rectify_tsig(p.sce, p.s, tsig, 0.18, 0.22), p.sce)) %>%   mutate(p.sce = case_when(     symphony==2 & movement==1 & section==2 & conductor==\"Rattle, Simon\" ~ p.sc*0.85,     (symphony==3 & movement==4 & section==2) |       (symphony==2 & movement==1 & section==2) ~ tmp_rectify(p.sce, p.sd, 3/2, 0.144, 0.1),     symphony==8 & movement==3 & section==1 ~ tmp_rectify(p.sce, p.sd, 2/3, 0.1, 0.1),     # exceptions checked by manual inspection     symphony==1 & movement==1 & section==2 & p.sce>100 ~ p.sce / 2,     symphony==3 & movement==2 & section==1 & conductor==\"Furtwängler, Wilhelm\" ~ p.sc / 2,     symphony==7 & movement==3 & section==1 & conductor==\"Klemperer, Otto\" ~ p.sc,     symphony==6 & movement==1 & section==1 & conductor==\"Pletnev, Mikhail\" ~ p.sc / 2,     TRUE ~ p.sce   )) %>%      # modify some p.sce due to general tempo variations   mutate(p.sce = case_when(     (symphony==1 & movement==3 & n>25 & n<51 & !grepl(\"Brüggen|Abbado|Hickox\", conductor)) |        (symphony==3 & movement==2 & (n<70 | (n>129 & n<140) | n>225)) |         (symphony==3 & movement==2 & n>190 & conductor==\"Tremblay, Jean-Philippe\") |       (symphony==3 & movement==3 & n>40 & n<78 & conductor==\"Mengelberg, Willem\") |       (symphony==3 & movement==3 & n>49 & n<78) |         (symphony==6 & movement==4 & n>55)      ~  p.sce*0.85,     (symphony==2 & movement==3 & n>30 & n<48 & conductor==\"Pletnev, Mikhail\")  ~ p.sce*0.75,     (symphony==1 & movement==3 & n>40 & n<51 & conductor==\"Hickox, Richard\") |       (symphony==2 & movement==3 & n>27 & n<46 & conductor==\"Harnoncourt, Nikolaus\") |       (symphony==3 & movement==2 & (n<130 | n>170) & !grepl(\"Leinsdorf|Gardiner\", conductor)) |       (symphony==6 & movement==2 & n<150) |       (symphony==8 & movement==3 & n>40 & n<71 & conductor!=\"Furtwängler, Wilhelm\")     ~ p.sce*0.9,     (symphony==7 & movement==2 & n>85 & n<135)  ~ p.sce*1.15,     (symphony==5 & movement==3 & n<34) ~ p.sce*(1 + 0.1*(1 - n/100)),     TRUE ~ p.sce   )) %>%      ungroup()"},{"path":"/articles/sym-analysis.html","id":"data-cleaning","dir":"Articles","previous_headings":"Tempo extraction","what":"Data cleaning","title":"Beethoven's symphonies analysis","text":"following, p.sce used reference find rectify harmonics histogram within certain tolerance. Tolerances defined case per case avoid harmonics getting mixed. , tempo values corrected using continuity criterion. typical recording, tempo can vary lot, harmonics correction based histogram peak might sometimes fail. cases can take advantage fact tempo usually varies smoothly: data point compared previous 3 samples search harmonic relationships previous step, corrected appropriately found. Finally, outliers, defined data points differ 2 standard deviations corrected peak, removed replaced interpolated values. results data cleaning process: Tempo data symphonic recordings. , Representative example raw data tempo extraction algorithm 3 different conductors performing 1st movement 3rd Symphony. Although time series seem noisy first sight, histogram right panel shows clear pattern: algorithm detects true tempo (components right Beethoven’s mark), also multiples (harmonics) frequency (example, x3/2 x3). b, Using Beethoven’s mark reference, harmonics raw data found rectified. c, final smoothing ensures consistency terms continuity throughout contiguous samples. top panel shows representative example raw data tempo extraction algorithm 3 different conductors performing 1st movement 3rd Symphony. Although time series seem noisy first sight, histogram right panel shows clear pattern: due rhythmic complexity Beethoven’s music, algorithm detects true tempo (components right Beethoven’s mark), also multiples (harmonics) frequency (example, x3/2 x3). Using Beethoven’s mark reference “true tempo”, harmonics raw data found rectified (central panel). final smoothing ensures consistency terms continuity throughout contiguous samples (bottom panel).","code":"# we will take a representative example for 3 conductors example.filter <- quo(   symphony==3 & movement==1 & grepl(\"Wand|Chailly|Immerseel\", conductor)) # raw tempo data, before any filtering example.window <- list(filter(dt.window, !!example.filter))  dt.window <- dt.window %>%   group_by(symphony, movement, conductor, section) %>%      # harmonics 3 and 1/3 (extreme cases)   mutate(tempo = tmp_rectify_tsig(tempo, p.sce, tsig, 0.14, 0.17))  %>%   mutate(tempo = tmp_rectify(tempo, p.sce, 3, 0.19, 0.5)) %>%    mutate(tempo = tmp_rectify(tempo, p.sce, 1/3, 0.5, 0.15)) %>%    # typical harmonics by time signature   mutate(tempo = case_when(      tsig!=3  ~ tmp_rectify(tempo, p.sce, 2, 0.18, 0.5),      tsig==3 & p.s<90 ~ tmp_rectify(tempo, p.sce, 2, 0.133, 0.15),       tsig==3 & p.s>90 ~ tmp_rectify(tempo, p.sce, 3/4, 0.13, 0.12),      TRUE ~ tempo   )) %>%       # harmonic 3/2   mutate(tempo = case_when(     (symphony==1 & movement==2 & ((n>36 & n<80) | n>110)) |       (symphony==2 & movement==1) |                   # tsig 2       (symphony==2 & movement==2 & section==1) |      # tsig 0.3       (symphony==3 & movement==2 & ((n>66 & n<130) | (n>175 & n<230))) | # tsig 2       (symphony==3 & movement==4 & section!=3) |      # tsig 2       (symphony==4 & movement==2) |                   # tsig 0.3       (symphony==5 & movement==2)  |                  # tsig 0.3       (symphony==7 & movement==1 & section==2) |      # tsig 2       (symphony==7 & movement==2 & ((n>44 & n <84) | n>133)) |       (symphony==8 & movement==2 & n>65) |            # tsig 2       (symphony==8 & movement==3 & n>38 & n<81) |     # tsig 0.3       (symphony==8 & movement==4)                     # tsig 2     ~ tmp_rectify(tempo, p.sce, c(3/4, 3/2), 0.12, 0.14),     TRUE ~ tempo   )) %>%       # harmonic 2/3   mutate(tempo = case_when(     tsig==0.3 |        (symphony==2 & movement==1) |                 # tsig 2       (symphony==2 & movement==4) |       (symphony==3 & movement==2) |                 # tsig 2       (symphony==5 & movement==1)                   # tsig 2     ~ tmp_rectify(tempo, p.sce, 2/3, 0.12, 0.115),     TRUE ~ tempo   )) %>%       # harmonics 2, 1/2, 4/3   mutate(tempo = case_when(     (symphony==2 & movement==4) |                # tsig 2       (symphony==5 & movement==4 & section==3)   # tsig 2     ~ tmp_rectify(tempo, p.sce, 1/2, 0.5, 0.21),     (symphony==2 & movement==1 & section==\"1\") |     (symphony==4 & movement==1 & section==\"1\") |        (symphony==7 & movement==1 & section==2 & conductor !=\"Pletnev, Mikhail\")     ~ tmp_rectify(tempo, p.sce, 4/3, 0.1, 0.15),      (symphony==1 & movement==1) |       (symphony==1 & movement==4 & n>100) |       (symphony==2 & movement==1 & n<15) |       (symphony==3 & movement==1) |       (symphony==4 & movement==3 & section==2) |       (symphony==6 & movement==2) |       (symphony==6 & movement==5) |       (symphony==7 & movement==1) |       (symphony==7 & movement==3 & section==2) |       (symphony==8 & movement==1)      ~ tmp_rectify(tempo, p.sce, 2, 0.2, 0.5),     TRUE ~ tempo   )) %>%      ungroup()  # tempo data after harmonic correction example.window <- c(example.window, list(filter(dt.window, !!example.filter))) dt.window <- dt.window %>%   group_by(symphony, movement, conductor, section) %>%      # continuity based on time signature   mutate(tempo = tmp_smooth(tempo, p.sce, tsig, 0.12, 0.15)) %>%    # special cases harmonic 3   mutate(tempo = if_else(     !(symphony==7 & movement==4 & conductor==\"Mengelberg, Willem\" & n>53) &       !(symphony==5 & movement==2 & conductor==\"Jochum, Eugen\" & n>109 & n <121) &       !(symphony==3 & movement==4 & conductor==\"Wand, Günter\" & n>155 & n <165),     tmp_smooth(tempo, p.sce, 3, 0.12, 0.12), tempo)) %>%      # special cases harmonic 2/3   mutate(tempo = if_else(     (symphony==8 & movement==3),     tmp_smooth(tempo, 0.95*p.sce, 0, 0.12, 0.12, 2/3), tempo)) %>%       # special cases harmonic 3/4   mutate(tempo = if_else(     tsig==3 | (symphony==1 & movement==2 & ((n>5 & n<87) | n>110)),     tmp_smooth(tempo, p.sce, 0, 0.12, 0.12, 3/4), tempo)) %>%      # remove outliers and interpolate   mutate(sd = sd(tempo)) %>%   mutate(tempo = if_else(tempo > p.sce + 2*sd, NA_real_, tempo)) %>%   mutate(tempo = if_else(tempo < p.sce - 2*sd, NA_real_, tempo)) %>%   mutate(tempo = zoo::na.approx(tempo, na.rm=FALSE)) %>%   ungroup() %>% na.omit() %>%      # recalculation of p.s and p.sce   group_by(symphony, movement, section) %>%   mutate(p.s = tmp_prevalent(tempo, 50)) %>%   group_by(symphony, movement, conductor, section) %>%   mutate(p.sce = tmp_prevalent(tempo, 50)) %>%   ungroup()  # tempo data after continuity correction example.window <- c(example.window, list(filter(dt.window, !!example.filter))) example.window <- bind_rows(example.window, .id=\"stage\") notes <- data.frame(   mark = rep(unique(example.window$mark), 5) * c(rep(1, 3), 3/2, 3),   label = paste0(\"Beethoven's mark\", c(rep(\"\", 3), \" x3/2\", \" x3\")),   vjust = c(rep(-.6, 4), 1.6),   stage = c(3, 2, 1, 1, 1)) breaks <- c(40, 50, 60, 80, 120, 160) expand <- c(39, 70) balpha <- 0.8  g <- ggplot(example.window) +   aes(n, tempo, color=conductor) +   ggthemes::geom_rangeframe(color=\"black\") +   geom_hline(aes(yintercept=mark), notes, alpha=balpha, linetype=2) +   facet_grid(\"stage\", scales=\"free_y\", space=\"free_y\") +   geom_line(alpha=1) + expand_limits(y=expand) +   scale_y_continuous(breaks=breaks) +   labs(y=\"Tempo [bpm]\", x=\"Sample\") + guides(color=FALSE) +   theme(strip.text=element_blank())  h <- ggplot(example.window) + theme_void() +   aes(tempo, after_stat(density)) +   coord_flip() + expand_limits(x=expand) +   facet_grid(\"stage\", scales=\"free_y\", space=\"free_y\") +   stat_bin(aes(fill=sapply(strsplit(as.character(conductor), \",\"), \"[\", 1)),            position=\"identity\", alpha=.7, binwidth=1, boundary=40) +   geom_vline(aes(xintercept=mark), notes, alpha=balpha, linetype=2) +   geom_text(aes(mark, 0.32, label=label, vjust=vjust), notes,             hjust=1, alpha=balpha, size=3) +   scale_x_continuous(breaks=breaks) + labs(fill=\"Conductor\") +   guides(color=FALSE, fill=guide_legend(title=, override.aes=list(alpha=1))) +   theme(legend.position=c(1, .85), legend.justification=c(1, 1),         legend.key.size=unit(5, \"pt\"), legend.title=element_text(size=10),         legend.text=element_text(size=8), strip.text=element_blank())  patchwork::wrap_plots(g, h, nrow=1, widths=c(5, 1.5))"},{"path":"/articles/sym-analysis.html","id":"validation","dir":"Articles","previous_headings":"Tempo extraction","what":"Validation","title":"Beethoven's symphonies analysis","text":"complementary methodology developed assess validity collection tempo measurements. sampled 30 seconds last minute every movement, thus compiling set finales, tempo arguably stable (see help(sym.sample). Tempo also extracted using Marsyas first pass, carefully curated hand. main data set validated comparing median tempo conductor mark median tempo obtained data set finales. Validation tempo data. , dot represents conductor, compares median tempo difference (tempo choice minus Beethoven’s mark) main validation data sets. b, dot represents metronome mark, compares median tempo main validation data sets. figures show 1:1 relation, ensures consistency main data set.","code":"dt.sample <- sym.sample %>%   left_join(sym.marks, by=c(\"symphony\", \"movement\", \"section\"))  dt.val.conductor <- dt.window %>%   group_by(conductor) %>%   summarise(window = median(tempo - mark, na.rm=TRUE)) %>%   left_join(     dt.sample %>%       group_by(conductor) %>%       summarise(sample = median(tempo - mark, na.rm=TRUE))) %>%   left_join(sym.recordings[,c(1, 8)], by=\"conductor\") %>%   mutate(ptype = droplevels(ptype, \"Romantic\"))  ggplot(dt.val.conductor) +   aes(window, sample) + ggthemes::geom_rangeframe() +   geom_abline(color=\"lightgray\") +   geom_point(aes(color=ptype)) + geom_smooth(method=lm, formula=y~x) +   ggpmisc::stat_poly_eq(formula=y~x, parse=TRUE) +   scale_color_discrete(breaks=levels(factor(dt.val.conductor$ptype))) +   labs(x=\"Main data set\", y=\"Validation data set\", color=\"Performance\",        subtitle=\"Median tempo difference by conductor [bpm]\") +   theme(legend.position=c(1, 0), legend.justification=c(1, 0))  dt.val.mark <- dt.window %>%   group_by(mark) %>%   summarise(window = median(tempo, na.rm=TRUE)) %>%   left_join(     dt.sample %>%       group_by(mark) %>%       summarise(sample = median(tempo, na.rm=TRUE)))  ggplot(dt.val.mark) +   aes(window, sample) + ggthemes::geom_rangeframe() +   geom_abline(color=\"lightgray\") +   geom_point() + geom_smooth(method=lm, formula=y~x) +   ggpmisc::stat_poly_eq(formula=y~x, parse=TRUE) +   labs(x=\"Main data set\", y=\"Validation data set\", color=\"Performance\",        subtitle=\"Median tempo by mark [bpm]\") +   theme(legend.position=c(0, 1), legend.justification=c(0, 1))"},{"path":[]},{"path":"/articles/sym-analysis.html","id":"by-conductor","dir":"Articles","previous_headings":"Results","what":"By conductor","title":"Beethoven's symphonies analysis","text":"process, obtained accurate description performed tempi Beethoven’s symphonies, supports previous qualitative analyses. Overall, performed tempi always slower Beethoven’s marks average, influence HI movement evident: attending median distribution, 12 15 fastest interpretations correspond HI HI-influenced performers. Tempo data symphonic recordings. Distribution tempo difference conductors’ tempo choices Beethoven’s marks. K. Böhm, bottom list, well known among critics one slowest performers Beethoven. end, R. Chailly conductor comes closer composer’s indications reportedly intended. even falls slightly behind Beethoven’s marks average, circumstance even praised critics. Remarkably, M. Pletnev extreme sparse distribution, reaching tempi far conductors. fact, critics consider artist contrasts, unorthodox unpredictable. Karl Böhm, bottom list, well known among critics one slowest performers Beethoven, sometimes even characterized “stiff” (see Carr). end, Riccardo Chailly conductor comes closer composer’s indications reportedly intended. even falls slightly behind Beethoven’s marks. critics even praised apparent failure. According Richard Osborne, “happily Chailly good musician put practice reported assertion performs everything ‘precisely Beethoven’s metronome mark’”. Mikhail Pletnev constitutes remarkable exception, times faster HI performers also slower Romantic conductor. Although generally rejects HI criteria, critics consider artist contrasts, unorthodox unpredictable. Osborne put , “every movement conducted Dr Jekyll another just around corner awaiting fate hands Mr Hyde.”","code":"dt.window <- dt.window %>%   left_join(sym.recordings[,c(1, 8)], by=\"conductor\") %>%   mutate(conductor = reorder(conductor, tempo - mark, median, na.rm=TRUE))  dt.window %>%   mutate(ptype = droplevels(ptype, \"Romantic\")) %>%   ggplot() + aes(tempo - mark, conductor) +   ggridges::geom_density_ridges(     aes(fill=ptype), color=\"lightgray\", size=0.3,     quantile_lines=TRUE, quantiles=2, vline_color=\"white\", vline_size=1) +   geom_vline(xintercept=0, color=\"black\") +   scale_fill_discrete(breaks=levels(factor(dt.window$ptype))) +   scale_y_discrete(position=\"right\") + xlim(-40, 20) +   labs(y=NULL, x=\"Tempo difference [bpm]\", fill=\"Performance\") +   theme(legend.position=c(0.97, 0.03), legend.justification=c(1, 0),          legend.background=element_rect(color=\"lightgray\"),          axis.ticks.y=element_blank(),          panel.grid.major.y=element_line(color=\"lightgray\", size=0.3))"},{"path":"/articles/sym-analysis.html","id":"by-mark","dir":"Articles","previous_headings":"Results","what":"By mark","title":"Beethoven's symphonies analysis","text":"Performed tempo modelled function metronome marks means mixed-effects linear model, using intercept random effect conducting style. Average slow-estimation stylistic group. Performed tempo stylistic criterion vs. Beethoven’s marks. panel shows distribution tempo choices mark. median distribution shown dot, grayed line represents 1:1 relation. top , mixed-effects regression line (blue) medians, 95% Confidence Interval (CI), quantifies effect group conductors: marks reduced average fixed amount along whole metronome range, preserving relative discrepancy groups. Interestingly, 72 bpm (7th Symphony, 4th movement; represented empty dot) seems mark groups accept accurate, therefore excluded regression model. model reveals common trend shared groups: 1:1 relationship marks (95% CI [0.95, 1.03]), significative random effect (LRT = 15.29, p < .001), suggests performers slow Beethoven’s marks, average, fixed amount different group conductors.","code":"dt.medians <- dt.window %>%   group_by(ptype, mark) %>%   summarise(tempo = median(tempo, na.rm=TRUE)) # all groups agree on this mark, as we'll see dt.exception <- filter(dt.medians, mark == 72) dt.medians <- filter(dt.medians, mark != 72)  fit <- lmer(tempo ~ mark + (1 | ptype), dt.medians)  re <- merTools::REsim(fit) names(re)[6] <- \"mean.se\" re <- unite_errors(re) re$mean <- fixef(fit)[1] + re$mean knitr::kable(re[, 1:4], caption=table2) dt.medians <- cbind(dt.medians, merTools::predictInterval(fit, level=0.95))  r2 <- performance::r2(fit) r2 <- paste0(   \"atop(\\\"Conditional \\\"~italic(R)^2~`=`~\", round(r2[[1]], 3),   \",~~~~\\\"Marginal\\\"~italic(R)^2~`=`~\", round(r2[[2]], 3), \")\") perf <- data.frame(mark=150, tempo=40, ptype=\"Romantic\", label=r2)  ggplot(dt.medians) +   aes(mark, tempo) + facet_grid(.~ptype) +   ggthemes::geom_rangeframe(color=\"black\") +   geom_abline(color=\"lightgray\") +   geom_violin(aes(group=mark), dt.window, scale=\"width\", color=\"lightgray\") +   geom_point() + geom_point(data=dt.exception, shape=1) +   geom_ribbon(aes(ymin=lwr, ymax=upr), alpha=.2) +   geom_line(aes(y=fit), color=\"blue\") +   geom_text(aes(label=label), perf, hjust=1, parse=TRUE) +   labs(x=\"Metronome mark [bpm]\", y=\"Performed tempo [bpm]\") +   theme(legend.position=c(0, 1), legend.justification=c(0, 1))"},{"path":"/articles/sym-analysis.html","id":"metronome-distortions","dir":"Articles","previous_headings":"Results","what":"Metronome distortions","title":"Beethoven's symphonies analysis","text":"Hereafter, consider average discrepancy measured model Romantic conductors proxy Beethoven’s intended tempo. Thus, interested comparing results possible distortions decrease metronome’s frequency comparable amount throughout range, without remarkable defects anomalous behaviors warn Beethoven flaw device. analyzed possible variation lower mass M distance shaft R resulting possible blow broken loosen , proposed Forsén et al. (2013). However, similar distortions mostly affect slower frequencies. also considered different inclinations metronome, maybe held unstable position piano rehearsing. affects gravitational acceleration experimented pendulum, caused quicker frequencies decelerate mostly , importantly, noticeable extremely sharp inclinations. Effect different metronome distortions frequency compared average slow-Romantic conductors. , Reduction distance lower mass shaft, \\(R\\). b, Reduction lower mass, \\(M\\). c, Inclination metronome. Finally, shift moving weight relative scale mechanism describes observed slow-tempo performers, turn can explained user reading marks moving weight. Effect different metronome distortions frequency compared average slow-Romantic conductors. d, Displacement scale relative moving weight.","code":"dt.window.r <- filter(dt.window, ptype==\"Romantic\") dt.medians.r <- filter(dt.medians, ptype==\"Romantic\") dt.exception.r <- filter(dt.exception, ptype==\"Romantic\")  # Beethoven's metronome parameters M. <- set_errors(4.008046, 0.1068220) mu. <- set_errors(0.6387369, 0.02924174) metr.params %>%   filter(model == \"Patent\") %>%   unite_errors() %>%   attach()  p <- ggplot(dt.medians.r) +   aes(mark, tempo) +   ggthemes::geom_rangeframe(aes(y=fit), color=\"black\") +   geom_abline(color=\"lightgray\") +   geom_line(aes(y=fit), color=\"red\") +   labs(x=\"Metronome mark [bpm]\", y=\"Performed tempo [bpm]\") +   theme(legend.position=c(.02, 1), legend.justification=c(0, 1)) p1 <- p + scale_color_gradient(breaks=c(0, -4, -8), name=\"Variation of R [mm]\") +   stat_function(fun=metr_model_bias, args=list(     R=c(R, R-2), M.=M., l=l, mu.=mu., A=A), aes(color=-2)) +   stat_function(fun=metr_model_bias, args=list(     R=c(R, R-5), M.=M., l=l, mu.=mu., A=A), aes(color=-5)) +   stat_function(fun=metr_model_bias, args=list(     R=c(R, R-8), M.=M., l=l, mu.=mu., A=A), aes(color=-8))  p2 <- p + scale_color_gradient(breaks=c(0, -10, -15), name=\"Variation of M [%]\") +   stat_function(fun=metr_model_bias, args=list(     R=R, M.=c(M., M.-0.05*M.), l=l, mu.=mu., A=A), aes(color=-5)) +   stat_function(fun=metr_model_bias, args=list(     R=R, M.=c(M., M.-0.10*M.), l=l, mu.=mu., A=A), aes(color=-10)) +   stat_function(fun=metr_model_bias, args=list(     R=R, M.=c(M., M.-0.15*M.), l=l, mu.=mu., A=A), aes(color=-15))  p3 <- p + scale_color_gradient(breaks=c(0, 20, 40), trans=\"reverse\", name=\"Variation of inclination [°]\") +   stat_function(fun=metr_model_bias, args=list(     R=R, M.=M., l=l, mu.=mu., A=A, g=9.807*c(1, cos(10*pi/180))), aes(color=10)) +   stat_function(fun=metr_model_bias, args=list(     R=R, M.=M., l=l, mu.=mu., A=A, g=9.807*c(1, cos(25*pi/180))), aes(color=25)) +   stat_function(fun=metr_model_bias, args=list(     R=R, M.=M., l=l, mu.=mu., A=A, g=9.807*c(1, cos(40*pi/180))), aes(color=40))  patchwork::wrap_plots(p1, p2, p3, nrow=1) p + scale_color_gradient(breaks=c(0, 12, 16), trans=\"reverse\", name=\"Scale shift [mm]\") +   stat_function(fun=metr_model_bias, args=list(     R=R, M.=M., l=l, mu.=mu., A=A, shift=8), aes(color=8)) +   stat_function(fun=metr_model_bias, args=list(     R=R, M.=M., l=l, mu.=mu., A=A, shift=12), aes(color=12)) +   stat_function(fun=metr_model_bias, args=list(     R=R, M.=M., l=l, mu.=mu., A=A, shift=16), aes(color=16))"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Almudena Martín-Castro. Author, copyright holder. Iñaki Ucar. Author, copyright holder, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martín-Castro , Ucar (2020). “Conductors' tempo choices shed light Beethoven's metronome.” PLOS ONE, 15(12), e0243616. doi: 10.1371/journal.pone.0243616.","code":"@Article{,   title = {Conductors' tempo choices shed light over Beethoven's metronome},   author = {Almudena Martín-Castro and Iñaki Ucar},   year = {2020},   journal = {PLOS ONE},   doi = {10.1371/journal.pone.0243616},   pages = {e0243616},   volume = {15},   number = {12}, }"},{"path":"/index.html","id":"bmetr-beethovens-metronome-analysis","dir":"","previous_headings":"","what":"Beethoven's Metronome Analysis","title":"Beethoven's Metronome Analysis","text":"Supporting data methods Almudena Martín-Castro Iñaki Ucar (2020). “Conductors’ tempo choices shed light Beethoven’s metronome.” PLOS ONE, 15(12), e0243616. DOI: 10.1371/journal.pone.0243616 Includes functions utilities modelling mechanical metronome filtering tempo signals.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Beethoven's Metronome Analysis","text":"installation GitHub requires remotes package.","code":"# install.packages(\"remotes\") remotes::install_github(\"Enchufa2/bmetr\")"},{"path":"/reference/bmetr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"bmetr: Beethoven's Metronome Analysis — bmetr-package","title":"bmetr: Beethoven's Metronome Analysis — bmetr-package","text":"Supporting data methods Martín-Castro & Ucar (2020). Includes functions utilities modelling mechanical metronome filtering tempo signals. See vignettes details.","code":""},{"path":"/reference/bmetr-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"bmetr: Beethoven's Metronome Analysis — bmetr-package","text":"Martín-Castro , Ucar (2020). Conductors' tempo choices shed light Beethoven's metronome. PLOS ONE 15(12), e0243616. doi: 10.1371/journal.pone.0243616","code":""},{"path":"/reference/bmetr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"bmetr: Beethoven's Metronome Analysis — bmetr-package","text":"Almudena Martín-Castro, Iñaki Ucar","code":""},{"path":"/reference/errors.html","id":null,"dir":"Reference","previous_headings":"","what":"Data Wrangling with errors — errors","title":"Data Wrangling with errors — errors","text":"Auxiliary functions perform common data wrangling operations errors-aware fashion, .e., preserve uncertainty metadata.","code":""},{"path":"/reference/errors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Wrangling with errors — errors","text":"","code":"gather_errors(.data, key, value, ...)  unite_errors(.data, suffix = \".se\")  separate_errors(.data, suffix = \".se\")"},{"path":"/reference/errors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data Wrangling with errors — errors","text":".data data frame. key, value names new key value columns, strings. ... selection columns gather. suffix suffix error column(s).","code":""},{"path":"/reference/errors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data Wrangling with errors — errors","text":"gather_errors errors-aware equivalent tidyr::gather. unite_errors separate_errors similar tidyr::unite tidyr::separate, errors objects. example, variable var class errors, separate_errors store numeric value var create another variable called var.se errors. Similarly, pair variables var var.se, unite_errors store errors object var remove var.se. Note suffix .se can changed.","code":""},{"path":"/reference/find_peaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Local Peaks — find_peaks","title":"Find Local Peaks — find_peaks","text":"Find local maxima neighbourhood. find local minima, just provide -x instead x.","code":""},{"path":"/reference/find_peaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Local Peaks — find_peaks","text":"","code":"find_peaks(x, m = 3)"},{"path":"/reference/find_peaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Local Peaks — find_peaks","text":"x numeric vector. m size neighbourhood.","code":""},{"path":"/reference/find_peaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find Local Peaks — find_peaks","text":"vector indices.","code":""},{"path":"/reference/find_peaks.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find Local Peaks — find_peaks","text":"Based https://github.com/stas-g/findPeaks.","code":""},{"path":"/reference/metr.data.html","id":null,"dir":"Reference","previous_headings":"","what":"Metronomes Data — metr.data","title":"Metronomes Data — metr.data","text":"Measurements five models metronome: Neewer, Neewer (photo), Patent, TB 06 TB 07. first two correspond contemporary metronome, Neewer NW-707. difference Neewer corresponds precise direct measurements dismantled metronome, Neewer (photo) measurements taken photograph. rest models follow methodology. third one, Patent, corresponds original diagram Maelzel's 1815 English patent. Finally, TB 06 TB 07 metronomes number 6 7, respectively, Tony Bingham's collection (see references).","code":""},{"path":"/reference/metr.data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metronomes Data — metr.data","text":"","code":"metr.neewer  metr.marks  metr.params"},{"path":"/reference/metr.data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Metronomes Data — metr.data","text":"metr.neewer provides oscillation frequency measurements Neewer metronome. metr.marks provides position measurements metronome mark metronomes. metr.params provides measurements fixed dimensions metronomes. additional columns suffixed .se standard errors corresponding variables units.","code":""},{"path":"/reference/metr.data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Metronomes Data — metr.data","text":"Bingham, T. Turner, . (2017) Metronomes Musical Time: Catalogue Tony Bingham Collection exhibition AUF TAKT! Held Museum für Musik, Basel. London. ISBN: 978-0-946113-11-8.","code":""},{"path":"/reference/metr_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Metronome Model Fit — metr_fit","title":"Metronome Model Fit — metr_fit","text":"Fit metronome's nondimensionalized masses, M. m. (see metr_model), set measurements parameters.","code":""},{"path":"/reference/metr_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metronome Model Fit — metr_fit","text":"","code":"metr_fit(.data, params, by = \"model\")  metr_predict(.fit, by = \"model\")"},{"path":"/reference/metr_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metronome Model Fit — metr_fit","text":".data measurements distance shaft metronome mark. must contain variables model, mark r, , e.g., metr.marks data set. params rest dimensions: correction center mass upper mass rcm, length rod shaft l, length rod shaft L, distance lower mass shaft R oscillation amplitude , , e.g., metr.params data set. variable group ; e.g., metronome model, fit several metronomes. .fit output metr_fit.","code":""},{"path":"/reference/metr_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metronome Model Fit — metr_fit","text":"grouped data frame model, M. (error), mu. (error) fit object.","code":""},{"path":"/reference/metr_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Metronome Model — metr_model","title":"Metronome Model — metr_model","text":"Functions compute metronome's oscillation frequency. metr_model main function. computes base value (metr_model_base), includes contribution mass rod (mu.), applies corrections due oscillation angle (metr_model_angle) friction (metr_model_friction).","code":""},{"path":"/reference/metr_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metronome Model — metr_model","text":"","code":"metr_model(r, R = 50, M. = 5, l = 220, L = R, mu. = 0, g = 9.807,   A = 0, ep0 = 0)  metr_model_base(r, R = 50, M. = 5, l = 220, L = R, mu. = 0, g = 9.807)  metr_model_angle(A, terms = 8)  metr_model_friction(r, R = 50, M. = 5, l = 220, L = R, mu. = 0, ep0 = 0)  metr_model_bias(mark, R = 50, M. = 5, l = 220, L = R, mu. = 0,   g = 9.807, A = 0, ep0 = 0, shift = 0)  metr_model_r(mark, R = 50, M. = 5, l = 220, L = R, mu. = 0, g = 9.807, A = 0)"},{"path":"/reference/metr_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metronome Model — metr_model","text":"r distance shaft center mass upper mass, mm. R distance shaft center mass lower mass, mm. M. nondimensionalized lower mass (lower mass divided upper mass). l length rod shaft, mm. L length rod shaft, mm. mu. nondimensionalized rod mass (rod mass divided upper mass). g standard gravity, m/s^2. oscillation amplitude, degrees. ep0 nondimensional friction parameter (>= 0). terms number terms approximate angle correction. mark metronome mark, pulses per minute. shift include shift rod respect scale, mm.","code":""},{"path":"/reference/metr_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metronome Model — metr_model","text":"metr_model, metr_model_base metr_model_bias return oscillation frequency pulses per minute. metr_model_angle metr_model_friction return value >= 1. metr_model_r returns distance shaft upper mass mm.","code":""},{"path":"/reference/metr_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Metronome Model — metr_model","text":"Function metr_model_bias computes, given metronome mark, resulting oscillation frequency alteration parameter. end, uses metr_model_r first calculate position upper mass metronome mark. value mu.=0 means rod considered massless. value =0 means correction applied due oscillation amplitude. value ep0=0 means movement frictionless. value ep0=0.5 means metronome stops due friction lowest possible frequency. compute frequency bias parameter, two values must supplied metr_model_bias. example, original position lower mass 50 mm, want calculate result lowering 5 mm, R=c(50, 55) supplied.","code":""},{"path":"/reference/sym.data.html","id":null,"dir":"Reference","previous_headings":"","what":"Beethoven's Symphonies Data — sym.data","title":"Beethoven's Symphonies Data — sym.data","text":"Six data sets tempo measurements plus additional information Beethoven's nine symphonies. Data sets sym.marks, sym.recordings sym.duration   provide detailed information Beethoven's annotations well   recordings selected study (complete symphonies 36 different   conductors). Data sets sym.window, sym.sample   provide tempo measurements extracted using Marsyas framework (  tempo estimation algorithm Percival Tzanetakis; see references)   distinct methodologies.","code":""},{"path":"/reference/sym.data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beethoven's Symphonies Data — sym.data","text":"","code":"sym.marks  sym.recordings  sym.duration  sym.window  sym.sample"},{"path":"/reference/sym.data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Beethoven's Symphonies Data — sym.data","text":"sym.marks provides complete timing information extracted Beethoven's scores: character annotations, tempo markings, beats bars nine symphonies. Note movements several character annotations (one section). Therefore, theoretical duration, minutes, without repetitions section can computed follows: (bar.tot - bar.1) * beat / mark. theoretical duration, minutes, repetitions just previous value + bar.rep * beat / mark. sym.recordings provides complete information albums analyzed work (nine symphonies 36 different conductors). sym.duration provides performed duration (track length) nine symphonies 36 different conductors. sym.window provides continuous tempo measurements per symphony, movement conductor means sliding window. sym.sample, contrast sym.window, provides single tempo estimation symphony, movement conductor. sample collected end track (\"coda\" movement), tempo arguably stable. variables sym.window, except n. Instead, sym.sample contains section column identify section tempo sampled. section identifier corresponds homonymous one present sym.marks.","code":""},{"path":"/reference/sym.data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Beethoven's Symphonies Data — sym.data","text":"Tzanetakis, G. Cook, P. (2000) \"MARSYAS: framework audio analysis.\" Organised Sound, 4(3):169-175 Percival, G. Tzanetakis, G. (2013) \"effective, simple tempo estimation method based self-similarity regularity.\" IEEE International Conference Acoustics, Speech Signal Processing, 241-245. Percival, G. Tzanetakis, G. (2014) \"Streamlined Tempo Estimation Based Autocorrelation Cross-correlation Pulses.\" IEEE/ACM Trans. Audio, Speech Lang. Proc., 22(12):1765-1776.","code":""},{"path":"/reference/tmp_rectify.html","id":null,"dir":"Reference","previous_headings":"","what":"Tempo Correction and Smoothing — tmp_rectify","title":"Tempo Correction and Smoothing — tmp_rectify","text":"Functions data cleaning. tmp_rectify general function rectify set tempo harmonics sequence given reference. tmp_rectify_tsig tmp_smooth wrappers around latter rectify specific set tempo harmonics given time signature smooth sequence tempi respectively. function tmp_prevalent intended find prevalent tempo sequence tempi.","code":""},{"path":"/reference/tmp_rectify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tempo Correction and Smoothing — tmp_rectify","text":"","code":"tmp_rectify(x, ref, harmonics, rtol, rtol2 = rtol, cond = any)  tmp_rectify_tsig(x, ref, tsig, rtol = 0.15, rtol2 = rtol)  tmp_smooth(x, ref, tsig, rtol = 0.1, rtol2 = rtol, ref2 = 1, nref = 3)  tmp_prevalent(x, breaks = 30)"},{"path":"/reference/tmp_rectify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tempo Correction and Smoothing — tmp_rectify","text":"x sequence tempi. ref tempo reference(s) harmonics. harmonics set tempo harmonics rectify. rtol, rtol2 ratios tolerance compute bounds determine whether given tempo harmonic ref. rtol2 can specified implement asymmetric bounds; otherwise, symmetric. cond condition apply correction. tsig time signature. Notably, function distinguishes binary time signatures (specified 2), time signatures ternary subdivision (specified 0.3). ref2 additional tempo harmonic consider. nref number previous samples take account. breaks number breaks compute histogram.","code":""},{"path":"/reference/tmp_rectify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tempo Correction and Smoothing — tmp_rectify","text":"rectified sequence, except tmp_prevalent, returns single value.","code":""}]
